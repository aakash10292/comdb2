#!/usr/bin/env bash
bash -n "$0" | exit 1

source ${TESTSROOTDIR}/tools/runit_common.sh

# Debug variable
debug=0
tbl=t1
dbnm=$1
lrl="${DBDIR}/${DBNAME}.lrl"
set -x
if [ "x$DBNAME" == "x" ] ; then
    echo "need a DB name"
    exit 1
fi
# Number of records to be added
nrecs=1000000

# Below function inserts nrecs number of records into the DB. It retries on failures. 

function insert_records
{
    j=0
    echo "Inserting $nrecs records."
    sum=0
    time while [[ $j -lt $nrecs ]]; do 
        #insert next, if error continue to try again
	cdb2sql ${CDB2_OPTIONS} $DBNAME default "insert into $tbl(a) values ($j)" 2>&1
        let j=j+1
    done
    echo "Done inserting $nrecs records."
}

function create_copy
{
	typeset destination=$1
	typeset filename=$2

	cdb2sql ${CDB2_OPTIONS} $DBNAME default 'exec procedure sys.cmd.send("flush")'
	echo "Creating backup" 
	$COMDB2AR_EXE c $lrl | lz4 stdin > ${destination}/${filename}.lz4 2>&1
	echo "Done Creating backup"
	sleep 5
	echo "truncating table $tbl"
        cdb2sql ${CDB2_OPTIONS} $DBNAME default "truncate $tbl"  >> insert.out 2>&1
	assertcnt $tbl 0
}

kill_by_pidfile() 
{
    pidfile=$1
    if [[ -f $pidfile ]]; then
        local pid=$(cat $pidfile)
        ps -p $pid -o args | grep -q "comdb2 ${DBNAME}"
        if [[ $? -eq 0 ]]; then
            echo "kill -9 $pid"
            kill -9 $pid
        fi
        ps -p $pid -o args | grep -q "comdb2 ${DBNAME}"
	if [[ $? -eq 1 ]]; then 
		echo "DB SUCCESSFULLY KILLED"
	fi
        rm -f $pidfile
    else
        failexit "kill_by_pidfile: pidfile $pidfile does not exist"
    fi
}

function reset_db_to_baseline
{
	typeset src=$1
	typeset delay=$2
	pushd $DBDIR
	echo "Reseting DB to baseline"
	echo "killing DB"
	kill_by_pidfile ${TMPDIR}/${DBNAME}.pid
	mv --backup=numbered $TESTDIR/logs/${DBNAME}.db $TESTDIR/logs/${DBNAME}.db.1
	#sleep $delay 
	lz4 -d $src | $COMDB2AR_EXE x $DBDIR $DBDIR >> reset.out 2>&1
	echo "$DBNAME: starting single node"
	echo "$COMDB2_EXE $DBNAME $TESTDIR/logs/${DBNAME}.db -pidfile ${TMPDIR}/$DBNAME.pid"
	$COMDB2_EXE $DBNAME >$TESTDIR/logs/${DBNAME}.db -pidfile ${TMPDIR}/$DBNAME.pid 2>&1 &
	popd
	sleep $delay
	assertcnt $tbl $nrecs
	do_verify $tbl
}


function update_recs
{
	typeset trans_size=$1
	j=0
	while [[ $j -lt $nrecs ]]; do
		i=0
		fl=insert_sql.$$.txt
		echo "BEGIN" > $fl
		while [[ ($j -lt $nrecs) && ($i -lt $trans_size) ]]; do
			echo "update $tbl set a=$j where a=$j" >> $fl
			let j=j+1
			let i=i+1
		done
		echo "COMMIT" >> $fl
		cdb2sql ${CDB2_OPTIONS} $DBNAME default - < $fl 2>&1
	done
}


function update_inline_sc
{
	cdb2sql ${CDB2_OPTIONS} $DBNAME default 'PUT TUNABLE pause_schema_change 1'
	#Make sure logical sc with async redo is off
	cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send(\"off logical_live_sc\")"
	echo "Starting inline schema change -"
	cdb2sql ${CDB2_OPTIONS} $DBNAME default "rebuild $tbl" &
	typeset waitpid=$!
	wait_till_paused
	#Schema change is paused .. We can run updates and unpause schema change
	echo "starting benchmark: "
	time update_recs $1
	echo "unpause schema change - "
	#cdb2sql ${CDB2_OPTIONS} $DBNAME default 'SELECT value AS "pause_schema_change" FROM comdb2_tunables WHERE name="pause_schema_change"'
	cdb2sql ${CDB2_OPTIONS} $DBNAME default 'PUT TUNABLE pause_schema_change 0'
	wait $waitpid
}


function wait_till_paused
{
	#Wait till coverted thread finishes converting the old table to new table
	grep -q "Schema changes paused" $TESTDIR/logs/${DBNAME}.db
	typeset grep_result=$?
	while [[  grep_result -eq 1 ]]; do
		sleep 1
		grep -q "Schema changes paused" $TESTDIR/logs/${DBNAME}.db
		let grep_result=$?
	done
}


function update_async_sc
{
	cdb2sql ${CDB2_OPTIONS} $DBNAME default 'PUT TUNABLE pause_schema_change 1'
	#switch on online schema change with logical redo
	cdb2sql ${CDB2_OPTIONS} $DBNAME default "exec procedure sys.cmd.send(\"on logical_live_sc\")"
	#Start online schema change
	echo "Starting online schema change with logical redo"
	cdb2sql ${CDB2_OPTIONS} $DBNAME default "rebuild $tbl" &
	typeset waitpid=$!
	wait_till_paused 
	#Schema change is paused .. We can run updates and unpause schema change
	echo "starting benchmark: "
	time update_recs $1
	echo "unpause schema change - "
	#cdb2sql ${CDB2_OPTIONS} $DBNAME default 'SELECT value AS "pause_schema_change" FROM comdb2_tunables WHERE name="pause_schema_change"'
	cdb2sql ${CDB2_OPTIONS} $DBNAME default 'PUT TUNABLE pause_schema_change 0'
	wait $waitpid
}

function run_tests
{
	typeset iters=1
	typeset trans_sizes=("$@")
	iter=0
	while [[ $iter -lt $iters ]]; do
		for i in "${trans_sizes[@]}"
		do
			echo "ITERATION $iter : TRANSACTION_SIZE $i"
			#Baseline benchmark - no schema change, simple update 
			echo "Updating records with no schema change"
			#truncate the DB log (as we grep for "Schema changes paused" on every benchmark..
			#We need to ensure the trace message from previous benchmark test, doesn't affect current benchmark
			echo '' >$TESTDIR/logs/${DBNAME}.db
			time update_recs $i 

			#Inline Schema Change benchmark - inline schema change, simple update
			echo "update records with async schema change"
			#truncate the DB log (as we grep for "Schema changes paused" on every benchmark..
			#We need to ensure the trace message from previous benchmark test, doesn't affect current benchmark
			echo '' >$TESTDIR/logs/${DBNAME}.db
			update_async_sc $i

			#Logical Schema Change benchmark - Logical schema change with async redo, simple update
			echo "update records with inline schema change"
			#truncate the DB log (as we grep for "Schema changes paused" on every benchmark..
			#We need to ensure the trace message from previous benchmark test, doesn't affect current benchmark
			echo '' >$TESTDIR/logs/${DBNAME}.db
			update_inline_sc $i		
		done
		let iter=iter+1
	done
}
	
echo "Starting test..."
cdb2sql ${CDB2_OPTIONS} $DBNAME default "drop table $tbl"
cdb2sql ${CDB2_OPTIONS} $DBNAME default "create table $tbl  { `cat $tbl.csc2 ` }"

# Insert the records
insert_records
assertcnt $tbl $nrecs
do_verify $tbl

#Create archive .. We will use this as baseline to run all benchmarks against
#create_copy "/db/backups" "test"
typeset trans_sizes=(1 10 100 1000)
run_tests "${trans_sizes[@]}"

exit 0


